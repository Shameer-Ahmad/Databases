We started out our project by coming up with an idea that felt personal to us. One thing we all found in common was a love for Boston food, and a desire to make it social! We wished there was a way for us to try out new restaurants in Boston while meeting other people also interested in similar restaurants or cuisines. We envisioned an application that could connect customers together into groups where they could participate in discounted events hosted by local restaurants - this would provide a social way to make friends, eat good food, and support local businesses. 

Beginning with the E-R Diagram, we instantly felt quite overwhelmed trying to figure out what entities we might want to include - there was a lot of debate over how relevant different fields might be to our project and we were getting nowhere. So instead, we decided to step back. 

We began again by imagining what our application would actually look like on the frontend, comparing it to other slightly similar sites like Goldbelly or DoorDash. From here, we were able to determine key goals and characteristics for our project, therefore getting on the same page to continue forward. Our project would thus consist of connecting restaurants (and discounted  events that they are hosting) with customers (who can either already be a part of a group or join a new one) to experience the unique variety of Boston cooking.

This supported an ease in our E-R analysis first on a chalkboard, and then after moving around attributes, entities, and associated relationships, we formatted this into a clear E-R diagram using app.diagrams.net where we could share the diagram between us and collaborate. 

One thing we noticed in making the E-R diagram was that there were a lot of attributes we were including which complicated the diagram and actually were foreign keys linking to other entities. For example, we removed an attribute called well_known_items from the restaurant entity, as instead these food items could be derived from the review and menu_item entities.

Next, we wrote out the relational schemas in a schema.txt file with the constraints -which led to significant normalizing as well. In our initial schema, the restaurant entity included both an address attribute (with street, city , and zip code) and a separate neighborhood attribute. This introduced redundancy and allowed for potential errors with data inconsistencies. We realized that the essential attribute was the address, since that is a core part of the restaurant, the neighborhood could be placed in a separate entity which could be referenced by using the zip-code as a foreign key. The idea is that the neighborhood could be located using the restaurant’s zip code. This enforces consistency since a restaurant’s neighborhood is now not entered multiple times in the table, which is error prone, instead it is derived through its zip code. 

Another thing we realized was that some of the basic attributes we outlined in our E-R diagram had to be better thought out. For example, we knew that we wanted reviews to contain a score, but in determining constraints we had to decide that we wanted it to be a float rating between 0.0 and 5.0 as compared to a star system like we’ve seen before on other applications.

Working through the stages of converting between these deliverables greatly supported our learning as we came to understand the intricacies of their structure better - for example, how multi-valued attributes must have their own relation schema. 

We worked collaboratively on coming up with an idea for our project and brainstorming its goals, what we wanted the frontend of the application to look like, and some basic implementation ideas. In terms of our individual contributions, Madie worked on the E-R diagram as well as the first drafts of the schema and SQL code. Anthony worked on the schema implementation and how some tables could be normalized to prevent duplication.

